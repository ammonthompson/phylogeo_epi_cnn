
loadPlugin("TensorPhylo", "/mnt/c/Users/ammon_work/Desktop/phylogenetics_software/tensorPhylo/tensorphyloprototype/build/installer/lib")
sim_num = 0
num_gen = 5000

tree = readTrees("seir2_sim" + sim_num + ".location_tree.nexus")[1]
taxa = tree.taxa()
data = readDiscreteCharacterData("seir2_sim" + sim_num + ".location_tree.nexus")
k    = data.getStateDescriptions().size()
num_locs = k / 2
I_state_index <- seq(2, k, by=2)

# set parameters
age <- tree.rootAge() + tree.branchLength(tree.nnodes())
moves = VectorMoves()

# make the tensors

############################
#### sampling rate param ###
############################

# only state I (even indexes in revbayes) is sampled
for(i in I_state_index){
	delta[i-1] <- 0
	delta[i] ~ dnExponential(1)
	delta[i].setValue(1)
	moves.append(mvScale(delta[i], weight = 5))
}
#delta <- [0, 0.2, 0, 0.3, 0, 0.4]

######################################################
#### INFECTION/CLADOGENESIS EXTINCTION/RECOVERY#######
######################################################

for(i in I_state_index){
	lambda[i-1] <- 0
	lambda[i] ~ dnExponential(1)
	lambda[i].setValue(1)
	moves.append(mvScale(lambda[i]))
}
#lambda <- [0, 4, 0, 3, 0, 5]

#epsilon ~ dnBeta(1,1)
#moves[2] = mvBetaProbability(epsilon)
#mu_param := lambda_param * epsilon
#mu_param ~ dnUniform(4,12)
#moves.append(mvSlide(mu_param))
#mu     := rep(mu_param, k)
mu <- [0., 1., 0, 1., 0., 1]

# mass-event parameters
rho <- 0.00000000000000000000001

tensorCount <- 0
# note this is now based on actual state label, not its index. 
# This is getting too confusing! I need to FIX THIS!
for(i in 0:5){
	if(i % 2 == 1){
		cladogenetic_tensor[++tensorCount] <- [i, i, i-1]
		cladogenetic_prob[tensorCount] <- 1.
		cladogenetic_tensor[++tensorCount] <-[i, i-1, i]
		cladogenetic_prob[tensorCount] <- 1.
	}else{
		cladogenetic_tensor[++tensorCount] <-[i, i, i]
	        cladogenetic_prob[tensorCount] <- 1.
	}

}
omega := fnCladogeneticProbabilityMatrix(cladogenetic_tensor, cladogenetic_prob, k) 


####################################
### ANAGENETIC STATE CHANGE ########
####################################
progression_rate ~ dnExponential(1)
moves.append(mvScale(progression_rate))
#progression_rate <- 0.003

for(i in 1:k){
	# set E state migrations and progression rates
	if((i%2) == 1){ # odd indexs are E states (even number state labels *face-palm*)
		for(j in i:k){
			if( j == i){
				m[i][j] <- 0			
			}else if(j == (i+1)){
				m[i][j] := progression_rate
			m[j][i] <- 0
			}else if((j % 2) == 1){
				m[i][j] ~ dnExponential(1)
				m[i][j].setValue(0.1)
				moves.append(mvScale(m[i][j], weight =5 ))
				#m[i][j] <- 0.1
				m[j][i] := m[i][j]
			}else{
				m[i][j] <- 0
				m[j][i] <- 0
			}
		}	
	# set I state migration rates (same as E state from same location)	
	}else{ 
		for(j in i:k){
			if( j == i){
				m[i][j] <- 0			
			}else if((j % 2) == 0){
				m[i][j] := m[i-1][j-1]
				m[j][i] := m[i-1][j-1]
			}else{
				m[i][j] <- 0
				m[j][i] <- 0
			}
		}	
	}
}
eta := fnFreeK(m, rescaled = FALSE)

root_freq <- simplex(rep(1, k))
root_state ~ dnCategorical(root_freq)
moves.append(mvRandomIntegerWalk(root_state))

# condition
#condition <- "sampled"
condition <- "time"
#condition <- "survival"
print("here")
# distribution object. also called dnGLHBDSP()
psi ~ dnGeneralizedLineageHeterogeneousBirthDeathProcess(
        originAge      = age,
        lambda       = lambda,
        pi           = root_freq,
	eta          = eta,
	omega        = omega,
	mu           = mu,
        delta        = delta,
	rho          = rho,
	condition    = condition,
        taxa         = taxa,
	nStates	     = k,
	zeroIndex    = TRUE,
	nProc	     = 4
)

psi.clamp(tree)
psi.clampCharData(data)

# model
my_model = model(psi)

# monitors
monitors = VectorMonitors()
monitors.append(mnScreen(printgen=100))
monitors.append(mnModel(printgen=1, filename="output/sim" + sim_num + "_tp.log"))

for(i in 0:(k-1)){
	monitors.append(mnFile(m[i+1], filename="output/mrate_sim" + sim_num + "_location_" + i + "_tp.log"))
}

# analysis
my_mcmc = mcmc(my_model, monitors, moves)
my_mcmc.burnin(max([2000, 0.1 * num_gen]), 100)
my_mcmc.run(num_gen)


q()








